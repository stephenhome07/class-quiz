<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>串聯與並聯電路模擬器 (Pizza 版)</title>
    
    <!-- 引入 Tailwind CSS (用於樣式) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 引入 Babel (用於解析 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen py-8">
    
    <!-- React 應用程式掛載點 -->
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- 圖示組件 (SVG) ---
        const Settings = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const Zap = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>;
        const Info = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>;
        const PizzaIcon = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M15 11h.01"/><path d="M11 15h.01"/><path d="M16 16h.01"/><path d="m2 16 20 6-6-20A20 20 0 0 0 2 16"/><path d="M5.71 17.11a17.04 17.04 0 0 1 11.4-11.4"/></svg>;
        const Activity = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></svg>;

        const SeriesParallelSimulator = () => {
            // --- 狀態管理 ---
            const [circuitType, setCircuitType] = useState('series');
            const [showAnalogy, setShowAnalogy] = useState(true);
            const [isSwitchClosed, setIsSwitchClosed] = useState(false);
            const [batteryVoltage, setBatteryVoltage] = useState(12);
            
            const R_BULB = 6; 

            // --- 計算電路數據 (僅用於儀表板顯示) ---
            const dashboardData = useMemo(() => {
                const v = Number.isFinite(batteryVoltage) ? batteryVoltage : 12;
                
                let iTotal = 0;
                if (circuitType === 'series') {
                    iTotal = v / (R_BULB * 2);
                } else {
                    const rTotal = (R_BULB * R_BULB) / (R_BULB + R_BULB); // 3
                    iTotal = v / rTotal;
                }
                
                return {
                    vTotal: v,
                    iTotal: isSwitchClosed ? iTotal : 0
                };
            }, [circuitType, isSwitchClosed, batteryVoltage]);

            // --- Canvas 相關 ---
            const canvasRef = useRef(null);
            const requestRef = useRef();
            const particlesRef = useRef([]);

            // 初始化粒子
            useEffect(() => {
                const count = 5;
                particlesRef.current = Array.from({ length: count }).map((_, i) => ({
                    id: i,
                    progress: i / count, // 均勻分佈
                    branch: i % 2 === 0 ? 1 : 2, // 1=上路/中路, 2=下路/外路
                }));
            }, []);

            // 動畫循環
            const animate = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                // 處理解析度
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                // 檢查是否需要調整大小，避免過度重繪
                if (canvas.width !== Math.floor(rect.width * dpr) || canvas.height !== Math.floor(rect.height * dpr)) {
                    canvas.width = rect.width * dpr;
                    canvas.height = rect.height * dpr;
                    ctx.scale(dpr, dpr);
                }
                const width = rect.width;
                const height = rect.height;

                ctx.clearRect(0, 0, width, height);

                // 1. 繪製背景電路
                drawCircuitBackground(ctx, width, height, circuitType);

                // 2. 決定速度 (開關沒開就靜止)
                const speed = isSwitchClosed ? 0.002 : 0;

                // 3. 更新並繪製粒子
                particlesRef.current.forEach(p => {
                    // 更新進度
                    p.progress += speed;
                    if (p.progress >= 1) {
                        p.progress = 0;
                        p.branch = Math.random() > 0.5 ? 1 : 2; // 重新隨機分配支路
                    }

                    // 計算狀態 (核心修正)
                    const particleState = getParticleVisualState(
                        p.progress, p.branch, circuitType, width, height, batteryVoltage
                    );

                    // 繪製
                    drawDeliveryGuy(ctx, particleState, showAnalogy);
                });

                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                requestRef.current = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(requestRef.current);
            }, [isSwitchClosed, circuitType, showAnalogy, batteryVoltage]);

            // ============================================================
            //  核心邏輯：根據「位置比例 (t)」直接決定 Pizza 數量
            // ============================================================
            const getParticleVisualState = (t, branch, type, w, h, maxV) => {
                const pad = 60;
                const cw = w - 2 * pad;
                const ch = h - 2 * pad;
                const startX = pad;
                const startY = pad;
                
                // 定義關鍵座標
                const leftX = startX;
                const rightX = startX + cw;
                const topY = startY;
                const bottomY = startY + ch;
                const midY = startY + ch / 2; // 電池所在高度

                let x, y;
                let pizzaCount = maxV; // 預設滿載
                let isEmpty = false;

                const safeMaxV = Number.isFinite(maxV) ? maxV : 12;

                if (type === 'series') {
                    // --- 串聯路徑 (大口字型) ---
                    if (t < 0.15) {
                        // 左側上升
                        x = leftX;
                        y = midY - (t / 0.15) * (midY - topY);
                        pizzaCount = safeMaxV;
                    } else if (t < 0.50) {
                        // 上側向右
                        const subT = (t - 0.15) / 0.35;
                        x = leftX + subT * (rightX - leftX);
                        y = topY;
                        pizzaCount = safeMaxV;
                    } else if (t < 0.85) {
                        // 右側向下 (關鍵區段：經過燈泡)
                        const subT = (t - 0.50) / 0.35;
                        x = rightX;
                        y = topY + subT * (bottomY - topY);
                        
                        // 燈泡A約在 1/3 處 (subT=0.33)
                        // 燈泡B約在 2/3 處 (subT=0.66)
                        if (subT < 0.33) {
                            pizzaCount = safeMaxV; // 還沒過第一顆
                        } else if (subT < 0.66) {
                            pizzaCount = safeMaxV / 2; // 過了第一顆，剩一半
                        } else {
                            pizzaCount = 0; // 過了第二顆，沒了
                            isEmpty = true;
                        }
                    } else {
                        // 下側回流 (左下 -> 電池)
                        const subT = (t - 0.85) / 0.15;
                        // 先水平回到左邊
                        if (subT < 0.7) {
                            x = rightX - (subT/0.7) * (rightX - leftX);
                            y = bottomY;
                        } else {
                            // 再垂直回到電池
                            x = leftX;
                            y = bottomY - ((subT-0.7)/0.3) * (bottomY - midY);
                        }
                        pizzaCount = 0;
                        isEmpty = true;
                    }

                } else {
                    // --- 並聯路徑 (梯形 Ladder) ---
                    const midX = startX + cw * 0.4;  // 第一支路 X
                    const farX = startX + cw * 0.8;  // 第二支路 X

                    if (t < 0.2) {
                        // 出發階段：電池 -> 左上 -> 頂線 -> 分岔點A
                        if (t < 0.05) { x = leftX; y = midY - (t/0.05)*(midY-topY); } // 上升
                        else { 
                            const subT = (t-0.05)/0.15; 
                            x = leftX + subT * (midX - leftX); 
                            y = topY; 
                        }
                        pizzaCount = safeMaxV;
                    } else if (t < 0.6) {
                        // 分支階段
                        const subT = (t - 0.2) / 0.4;
                        
                        if (branch === 1) { 
                            // 支路 A (中路): 直接向下
                            x = midX;
                            y = topY + subT * (bottomY - topY);
                            // 過了一半就是過了燈泡
                            if (subT > 0.5) { pizzaCount = 0; isEmpty = true; }
                            else { pizzaCount = safeMaxV; }
                        } else {
                            // 支路 B (遠路): 繼續向右 -> 向下 -> 向左回
                            if (subT < 0.2) { // 向右到遠端
                                x = midX + (subT/0.2)*(farX - midX); y = topY;
                                pizzaCount = safeMaxV;
                            } else if (subT < 0.8) { // 向下過燈泡
                                const dT = (subT-0.2)/0.6;
                                x = farX; y = topY + dT * (bottomY - topY);
                                if (dT > 0.5) { pizzaCount = 0; isEmpty = true; }
                                else { pizzaCount = safeMaxV; }
                            } else { // 底部向左匯合
                                const bT = (subT-0.8)/0.2;
                                x = farX - bT * (farX - midX); y = bottomY;
                                pizzaCount = 0; isEmpty = true;
                            }
                        }
                    } else {
                        // 回流階段: 底部中點 -> 左下 -> 電池
                        const subT = (t - 0.6) / 0.4;
                        if (subT < 0.7) {
                            x = midX - (subT/0.7) * (midX - leftX);
                            y = bottomY;
                        } else {
                            x = leftX;
                            y = bottomY - ((subT-0.7)/0.3) * (bottomY - midY);
                        }
                        pizzaCount = 0;
                        isEmpty = true;
                    }
                }

                return { x, y, pizzaCount: Math.round(pizzaCount), isEmpty };
            };

            // ============================================================
            //  繪圖邏輯
            // ============================================================
            const drawCircuitBackground = (ctx, w, h, type) => {
                const pad = 60;
                const cw = w - 2 * pad;
                const ch = h - 2 * pad;
                const startX = pad;
                const startY = pad;
                const midY = startY + ch / 2;
                const rightX = startX + cw;
                const bottomY = startY + ch;

                ctx.lineWidth = 6;
                ctx.strokeStyle = '#94a3b8';
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();

                if (type === 'series') {
                    // 外框
                    ctx.strokeRect(startX, startY, cw, ch);
                    // 電池 (左中)
                    drawBattery(ctx, startX, midY);
                    // 燈泡 (右側 1/3 和 2/3 處)
                    drawBulb(ctx, rightX, startY + ch * 0.33, 'A');
                    drawBulb(ctx, rightX, startY + ch * 0.66, 'B');
                } else {
                    const midX = startX + cw * 0.4;
                    const farX = startX + cw * 0.8;

                    // 主迴路 (左邊)
                    ctx.moveTo(startX, startY); ctx.lineTo(startX, bottomY); ctx.stroke();
                    
                    // 橫線 (頂與底)
                    ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(farX, startY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(startX, bottomY); ctx.lineTo(farX, bottomY); ctx.stroke();

                    // 支路 A (中)
                    ctx.beginPath(); ctx.moveTo(midX, startY); ctx.lineTo(midX, bottomY); ctx.stroke();
                    // 支路 B (右)
                    ctx.beginPath(); ctx.moveTo(farX, startY); ctx.lineTo(farX, bottomY); ctx.stroke();

                    drawBattery(ctx, startX, midY);
                    drawBulb(ctx, midX, midY, 'A');
                    drawBulb(ctx, farX, midY, 'B');
                }
            };

            const drawBattery = (ctx, x, y) => {
                ctx.fillStyle = '#fff'; ctx.fillRect(x - 15, y - 25, 30, 50);
                ctx.lineWidth = 3; ctx.strokeStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(x - 10, y - 10); ctx.lineTo(x + 10, y - 10); // 長 +
                ctx.moveTo(x - 6, y + 10); ctx.lineTo(x + 6, y + 10);   // 短 -
                ctx.stroke();
                ctx.fillStyle = 'red'; ctx.font = 'bold 20px Arial'; ctx.fillText('+', x - 25, y - 5);
            };

            const drawBulb = (ctx, x, y, label) => {
                ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI * 2); ctx.fill();
                ctx.lineWidth = 2; ctx.strokeStyle = '#000'; ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x - 10, y - 10); ctx.lineTo(x + 10, y + 10);
                ctx.moveTo(x + 10, y - 10); ctx.lineTo(x - 10, y + 10); ctx.stroke();
                ctx.fillStyle = '#000'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.fillText(label, x + 30, y + 5);
            };

            const drawDeliveryGuy = (ctx, state, useAnalogy) => {
                const { x, y, pizzaCount, isEmpty } = state;
                const scale = 1.5;

                if (!useAnalogy) {
                    // 電子模式
                    ctx.fillStyle = '#2563eb';
                    ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI * 2); ctx.fill();
                    return;
                }

                // 外賣員模式
                const isGray = isEmpty;
                
                // 身體
                ctx.fillStyle = isGray ? '#9ca3af' : '#3b82f6';
                ctx.beginPath(); ctx.ellipse(x, y + 5 * scale, 8 * scale, 6 * scale, 0, 0, Math.PI * 2); ctx.fill();
                // 頭
                ctx.fillStyle = isGray ? '#e5e7eb' : '#fbbf24';
                ctx.beginPath(); ctx.arc(x, y - 4 * scale, 6 * scale, 0, Math.PI * 2); ctx.fill();

                // --- Pizza 顯示 (右側) ---
                const trayX = x + 10 * scale;
                const trayY = y;
                
                // 托盤
                ctx.fillStyle = '#cbd5e1'; ctx.fillRect(trayX, trayY, 24 * scale, 4);
                ctx.strokeStyle = '#64748b'; ctx.strokeRect(trayX, trayY, 24 * scale, 4);

                // 盒子堆疊
                const safeCount = Math.max(0, Math.floor(pizzaCount)); // 取整數
                const boxes = Math.ceil(safeCount / 3);
                const boxW = 20 * scale;
                const boxH = 4 * scale;
                const centerX = trayX + 12 * scale; // 托盤中心

                if (boxes > 0) {
                    ctx.fillStyle = '#ef4444'; ctx.strokeStyle = '#7f1d1d'; ctx.lineWidth = 1;
                    for (let i = 0; i < boxes; i++) {
                        const by = trayY - (i + 1) * boxH;
                        ctx.fillRect(centerX - boxW / 2, by, boxW, boxH);
                        ctx.strokeRect(centerX - boxW / 2, by, boxW, boxH);
                    }
                }

                // 數字標籤 (強制顯示)
                ctx.save();
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                const textStr = safeCount.toString();
                const textY = boxes > 0 ? trayY - (boxes * boxH) - 10 : trayY - 15;
                
                // 畫背景讓字清楚
                const metrics = ctx.measureText(textStr);
                const bgW = Math.max(20, metrics.width + 8);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillRect(centerX - bgW / 2, textY - 18, bgW, 22);
                
                // 畫字
                ctx.fillStyle = safeCount === 0 ? '#ef4444' : '#000';
                ctx.fillText(textStr, centerX, textY);
                
                // Empty 標籤
                if (safeCount === 0) {
                    ctx.font = '12px Arial';
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText("Empty", centerX, textY + 14);
                }
                ctx.restore();
            };

            return (
                <div className="flex flex-col w-full max-w-5xl mx-auto p-4 bg-gray-50 rounded-xl shadow-lg font-sans text-gray-800">
                <header className="mb-4 flex items-center justify-between border-b pb-4">
                    <h1 className="text-2xl font-bold flex items-center gap-2">
                    <PizzaIcon /> Pizza 電路模擬器
                    </h1>
                    <div className="text-sm text-gray-500">外賣員=電流, Pizza=電壓</div>
                </header>

                <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                    <div className="lg:col-span-1 space-y-4">
                        <div className="bg-white p-4 rounded-lg shadow space-y-4">
                            <h3 className="font-bold text-gray-700 flex items-center gap-2"><Settings />設定</h3>
                            
                            <div className="flex flex-col gap-2">
                                <button onClick={() => setCircuitType('series')} className={`p-2 rounded border font-bold ${circuitType==='series'?'bg-blue-100 border-blue-500 text-blue-700':'bg-gray-50'}`}>串聯 (Series)</button>
                                <button onClick={() => setCircuitType('parallel')} className={`p-2 rounded border font-bold ${circuitType==='parallel'?'bg-green-100 border-green-500 text-green-700':'bg-gray-50'}`}>並聯 (Parallel)</button>
                            </div>

                            <button onClick={() => setIsSwitchClosed(!isSwitchClosed)} className={`w-full p-3 rounded font-bold text-white flex justify-center items-center gap-2 ${isSwitchClosed?'bg-red-500':'bg-green-500'}`}>
                                <Activity /> {isSwitchClosed ? '停止' : '開始'}
                            </button>

                            <div className="flex items-center gap-2 p-2 bg-orange-50 rounded border border-orange-200">
                                <input type="checkbox" checked={showAnalogy} onChange={e=>setShowAnalogy(e.target.checked)} />
                                <span className="font-bold text-orange-800 text-sm">顯示 Pizza 模式</span>
                            </div>

                            <div className="pt-2 border-t">
                                <label className="text-sm font-bold block mb-1">Pizza 數量 (V): {batteryVoltage}</label>
                                <input type="range" min="6" max="24" step="6" value={batteryVoltage} onChange={e=>setBatteryVoltage(parseInt(e.target.value))} className="w-full" />
                            </div>
                        </div>
                    </div>

                    <div className="lg:col-span-3">
                        <div className="bg-white rounded-lg shadow border border-gray-300 relative h-[500px]">
                            <canvas ref={canvasRef} className="w-full h-full block" />
                        </div>
                        
                        <div className="mt-4 grid grid-cols-2 gap-4">
                            <div className="bg-blue-50 p-3 rounded border border-blue-200">
                                <div className="text-sm text-blue-800 font-bold">總電流 (I_total)</div>
                                <div className="text-xl font-mono text-blue-600">{dashboardData.iTotal.toFixed(2)} A</div>
                            </div>
                            <div className="bg-red-50 p-3 rounded border border-red-200">
                                <div className="text-sm text-red-800 font-bold">總電壓 (V_total)</div>
                                <div className="text-xl font-mono text-red-600">{dashboardData.vTotal} V</div>
                            </div>
                        </div>
                    </div>
                </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SeriesParallelSimulator />);
    </script>
</body>
</html>